<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[Java 日志框架 Logback]]></title>
      <url>/java/2018/08/22/Java-%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6-Logback/</url>
      <content type="text"><![CDATA[Logback 简介Logback 是一个稳定、高效、快速的 Java 日志框架，作为 log4j 的改良版，它与 log4j 相比拥有更多特性，也带来了很大的性能提升，具体改进可以查看官方文档。Logback 主要分为三个模块  logback-core：核心模块，作为 classic 和 access 模块的基础  logback-classic：实现了 slf4j API，配合 slf4j 使用，可以方便的切换其他日志框架  logback-access：​​与Servlet容器（如Tomcat和Jetty）集成，提供了 HTTP 访问日志接口Logback 加载Logback 启动加载时会按一下顺序查找配置文件  在系统配置文件 System Properties 中寻找是否有 logback.configurationFile 对应的 value  在 classpath 下寻找是否有 logback.groovy（logback支持groovy与xml两种配置方式）  在 classpath 下寻找是否有 logback-test.xml  在 classpath 下寻找是否有 logback.xml当查找到任意一项配置存在后就不进行后续扫描了，会使用该配置文件进行初始化，如果没有查找到配置文件，Logback会创建一个向控制台输出日志的配置。Logback 配置根节点 configurationconfiguration 是配置文件的根节点，有三个属性：  debug：默认值为false，设置为true时，将打印出 logback 内部日志信息，实时查看 logback 运行状态。  scan：默认值为true，设置为true时，配置文件如果发生改变，将会被重新加载。  scanPeriod：当 scan 为 true 时，此属性才会生效。设置扫描配置文件是否有修改的时间间隔，默认单位是毫秒。默认的时间间隔为1分钟（60 second）配置代码：&lt;configuration scan="true" scanPeriod="60 second" debug="true"&gt;&lt;/configuration&gt;设置上下文名称 contextName每个 logger 都关联到 logger 上下文，默认上下文名称为 “default”。但可以使用&lt;contextName&gt;设置成其他名字，用于区分不同应用程序的记录。一旦设置，不能修改。配置代码：&lt;contextName&gt;new context name&lt;/contextName&gt;设置变量 propertyproperty 是用来定义变量的标签，设置之后可以用 ${变量名} 访问，有三个属性：  name：变量名称  value：变量值  file：指定配置文件的路径，它的作用在于，如果有多个配置信息的话，可以直接写在配置文件中，然后通过file引入  resource：作用与 file 一样，不同的是它可以直接从 classpath 路径下引入配置文件配置代码：&lt;!-- name value 形式 --&gt;&lt;property name="APP_Name" value="MyApp"/&gt;&lt;contextName&gt;${APP_Name}&lt;/contextName&gt;  &lt;!-- file 形式 --&gt;variables.properties:APP_Name=MyAppLOG_PATH=logs&lt;property file="src/main/java/config/variables.properties" /&gt;&lt;contextName&gt;${APP_Name}&lt;/contextName&gt; &lt;!-- resource 形式 --&gt;variables.properties:APP_Name=MyAppLOG_PATH=logs&lt;property resource="variables.properties" /&gt;&lt;contextName&gt;${APP_Name}&lt;/contextName&gt; configuration 子节点 logger、rootlogger 用来设置某一个类或者某个包的日志输出级别、以及输出位置（指定 appender），有三个属性：  name：指定的包名或者类名  level：输出日志级别，如果未设置此级别，那么当前 logger 会向上继承最近一个非空级别，root 默认有一个 level 为 debug  additivity：是否将日志向上级传递，默认为 truelogger 通过设置子节点 appender-ref 来指定日志输出位置，一个 logger 可以设置多个 appender-ref 配置代码：&lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;        &lt;encoder&gt;            &lt;Pattern&gt;[%d{HH:mm:ss.SSS}] [%5level] [%thread] %logger{36} %msg%n&lt;/Pattern&gt;            &lt;charset&gt;UTF-8&lt;/charset&gt;        &lt;/encoder&gt;&lt;/appender&gt;&lt;logger name="X" level="INFO" additivity="false"&gt;        &lt;appender-ref ref="STDOUT"/&gt;&lt;/logger&gt;&lt;logger name="X.Y" additivity="false"&gt;    &lt;appender-ref ref="STDOUT"/&gt;&lt;/logger&gt;root 是一个特殊的 logger , 是所有 logger 的根节点，因为已经被命名为 root 同时也没有父级别，所以只有一个属性 level，默认为 DEBUG 配置代码：&lt;root level="DEBUG"&gt;    &lt;appender-ref ref="STDOUT"/&gt;    &lt;appender-ref ref="ASYNC"/&gt;&lt;/root&gt;level 继承示例1：            logger name      level      实际 level                  root      DEBUG      DEBUG              X      未设置      DEBUG              X.Y      未设置      DEBUG              X.Y.Z      未设置      DEBUG      示例1只有 root 设置了一个级别，X，X.Y 和 X.Y.Z 这三个 logger 未设置日志输出级别，因此向上继承 root 的级别，即 DEBUGlevel 继承示例2：            logger name      level      实际 level                  root      ERROR      ERROR              X      INFO      INFO              X.Y      DEBUG      DEBUG              X.Y.Z      WARN      WARN      示例2所有 logger 都设置了一个日志级别，等级继承不起作用。level 继承示例3：            logger name      level      实际 level                  root      DEBUG      DEBUG              X      INFO      INFO              X.Y      未设置      INFO              X.Y.Z      WARN      WARN      示例3 X.Y 没有设置日志级别，向上继承最近一个有日志级别的 logger X 的值。level 继承示例4：            logger name      level      实际 level                  root      DEBUG      DEBUG              X      INFO      INFO              X.Y      未设置      INFO              X.Y.Z      未设置      INFO      示例4 X.Y 和 X.Y.Z 没有设置日志级别，向上继承最近一个有日志级别的 logger X 的值。configuration 子节点 appenderappender 是负责写日志的组件，有两个属性（使用时都必须配置）：  name：设置 appender 的名称，供后面 logger 设置引用  class：设置 appender 的全路径类名，例：ch.qos.logback.core.ConsoleAppenderappender 可以包含零个或一个 layout ，零个或多个 encoder 元素以及零个或多个 filter 元素。除了这三个元素之外，还可以包含与 appender 类的 JavaBean 属性相对应的任意数量的元素，如： file 指定日志文件名称。  layout：对日志进行格式化  encoder： encoder 是0.9.19版本之后引进的，以前的版本使用 layout ，logback极力推荐的是使用 encoder 而不是 layout  filter：对日志进行过滤appender 常用的有以下几种：  ConsoleAppender：输出到控制台，或者更确切地说是输出到 System.out 或 System.err，前者是默认目标。&lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;    &lt;encoder&gt;      &lt;pattern&gt;%msg%n&lt;/pattern&gt;    &lt;/encoder&gt;    &lt;target&gt;        System.err    &lt;/target&gt;&lt;/appender&gt;  FileAppender：输出到文件，目标文件由 file 指定。如果该文件已存在，则根据 append 属性的值确定追加或者清空文件。&lt;appender name="FILE" class="ch.qos.logback.core.FileAppender"&gt;    &lt;file&gt;testFile.log&lt;/file&gt;    &lt;append&gt;true&lt;/append&gt;    &lt;!-- set immediateFlush to false for much higher logging throughput --&gt;    &lt;immediateFlush&gt;true&lt;/immediateFlush&gt;    &lt;!-- encoders are assigned the type         ch.qos.logback.classic.encoder.PatternLayoutEncoder by default --&gt;    &lt;encoder&gt;      &lt;pattern&gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt;    &lt;/encoder&gt;&lt;/appender&gt;  RollingFileAppender：继承自 FileAppender ,提供了滚动记录的功能，先将日志记录到指定文件，当触发某个条件时，将日志记录到其他文件。有两个重要的子节点 rollingPolicy  和  triggeringPolicy          rollingPolicy：指定发生滚动时 RollingFileAppender 的行为，例如可以切换日志文件      triggeringPolicy：指定 RollingFileAppender 何时触发滚动。      &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;    &lt;file&gt;logFile.log&lt;/file&gt;    &lt;!-- 根据时间来制定滚动策略，既负责滚动也负责触发滚动。 --&gt;    &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;      &lt;!-- 每天生成日志文件 --&gt;      &lt;fileNamePattern&gt;logFile.%d{yyyy-MM-dd}.log&lt;/fileNamePattern&gt;      &lt;!-- 保留最近30天的日志文件 --&gt;      &lt;maxHistory&gt;30&lt;/maxHistory&gt;      &lt;totalSizeCap&gt;3GB&lt;/totalSizeCap&gt;    &lt;/rollingPolicy&gt;    &lt;encoder&gt;      &lt;pattern&gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt;    &lt;/encoder&gt;&lt;/appender&gt; &lt;appender name="ROLLING" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;    &lt;file&gt;mylog.txt&lt;/file&gt;    &lt;!-- 基于文件大小和时间的滚动策略 --&gt;    &lt;rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy"&gt;      &lt;!-- 每天生成日志文件 --&gt;      &lt;fileNamePattern&gt;mylog-%d{yyyy-MM-dd}.%i.txt&lt;/fileNamePattern&gt;       &lt;!-- 每个日志文件最多 100MB, 保留 60 天, 最多 20 GB--&gt;       &lt;maxFileSize&gt;100MB&lt;/maxFileSize&gt;           &lt;maxHistory&gt;60&lt;/maxHistory&gt;       &lt;totalSizeCap&gt;20GB&lt;/totalSizeCap&gt;    &lt;/rollingPolicy&gt;    &lt;encoder&gt;      &lt;pattern&gt;%msg%n&lt;/pattern&gt;    &lt;/encoder&gt;&lt;/appender&gt;  AsyncAppender：异步记录日志，它仅仅作为一个调度者，因此必须引用另一个 appender 来做日志输出。  discardingThreshold：默认情况下，当阻塞队列剩余容量为20％时，它将丢弃级别为 TRACE，DEBUG 和 INFO 的事件，仅保留级别为 WARN 和 ERROR 的事件。设置为0即可保留所有事件。  queueSize：阻塞队列的最大容量。默认情况下，queueSize 为 256。  appender-ref：表示 AsyncAppender 使用哪个具体的 appender 进行日志输出。&lt;!-- 异步输出 --&gt;  &lt;appender name ="ASYNC" class= "ch.qos.logback.classic.AsyncAppender"&gt;          &lt;!-- 不丢失日志 --&gt;          &lt;discardingThreshold&gt;0&lt;/discardingThreshold&gt;          &lt;!-- 更改默认的队列的深度,该值会影响性能.默认值为256 --&gt;          &lt;queueSize&gt;256&lt;/queueSize&gt;          &lt;!-- 添加附加的appender,最多只能添加一个 --&gt;          &lt;appender-ref ref ="FILE"/&gt;  &lt;/appender&gt;     &lt;logger name="X" level="DEBUG"&gt;    &lt;appender-ref ref="ASYNC" /&gt;&lt;/logger&gt;]]></content>
      <categories>
        
          <category> Java </category>
        
      </categories>
      <tags>
        
          <tag> Java </tag>
        
          <tag> Logback </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[基于 CentOS 7 + Nginx + Tomcat 的负载均衡服务器的搭建]]></title>
      <url>/%E6%9C%8D%E5%8A%A1%E5%99%A8/2018/05/13/%E5%9F%BA%E4%BA%8E-CentOS-7-+-Nginx-+-Tomcat-%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      <content type="text"><![CDATA[前言本文主要介绍如何在 CentOS 上从零开始使用 Nginx + Tomcat 搭建一个负载均衡服务器。在搭建过程中学习 Nginx 的基本使用方式以及 Tomcat 相关知识，进一步理解两者结合后的运行原理。Nginx 安装使用源码编译的方式在 CentOS 上安装 Nginx 主要有以下几个步骤：      安装运行环境          Nginx 是使用 C 语言开发的，编译依赖 gcc 环境，因此如果没有 gcc 需要先安装：         yum install -y gcc-c++              安装 Nginx 依赖库         # rewrite模块需要 PCRE(Perl Compatible Regular Expressions),pcre-devel 库 yum install -y pcre pcre-devel  # gzip模块需要 zlib 库 yum install -y zlib # ssl 功能需要 OpenSSL 库 yum install -y openssl openssl-devel            下载 Ngnix    从 Ngnix 官网下载最新稳定版，目前是 1.12.2     # 如果还未安装 wget 请先执行安装命令 yum install -y wget # 使用 wget 命令下载 wget -c https://nginx.org/download/nginx-1.12.2.tar.gz # 解压文件 tar -zxvf nginx-1.12.2.tar.gz  # 进入解压后的目录 cd nginx-1.12.2 # 使用默认配置 ./configure            编译安装 Nginx    编译安装十分简单，只需执行两个命令即可     # 编译 make # 安装 make install # 安装目录默认为 /usr/local/nginx # 可以使用 whereis nginx 查找 [root@localhost nginx-1.12.2]# whereis nginx nginx: /usr/local/nginx            启动测试    Ngnix 安装完成后即可启动测试是否可以正常运行     # 进入 ngnix 执行文件目录 cd /usr/local/ngnix/sbin # 启动 # ./nginx  启动 # ./nginx -s stop  停止（先查出 nginx 进程 id 再使用 kill 命令强制杀掉进程） # ./nginx -s quit  退出（等待 nginx 进程将任务处理完毕再停止） # ./nginx -s reload  重新加载，适用于修改了配置文件之后操作 ./nginx # 启动之后可以通过 ps 命令查询 ngnix 进程 ps aux|grep nginx # 访问localhost:80 测试 ngnix 是否正常运行，返回 nginx 欢迎页表示正常运行 [root@localhost sbin]# curl localhost:80 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Welcome to nginx!&lt;/title&gt; &lt;style&gt;     body {         width: 35em;         margin: 0 auto;         font-family: Tahoma, Verdana, Arial, sans-serif;     } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Welcome to nginx!&lt;/h1&gt; &lt;p&gt;If you see this page, the nginx web server is successfully installed and working. Further configuration is required.&lt;/p&gt;     &lt;p&gt;For online documentation and support please refer to &lt;a href="http://nginx.org/"&gt;nginx.org&lt;/a&gt;.&lt;br/&gt; Commercial support is available at &lt;a href="http://nginx.com/"&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;     &lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt;      Tomcat 多实例部署配置Tomcat 单实例部署，即一个 Tomcat 服务器运行时，不存在负载均衡一说，因此，我们首先要做的就是实现 Tomcat 多实例部署，将我们的同一个应用程序部署在多个 Tomcat 服务器上同时运行。主要步骤如下：  安装 JDK（如果本机已经安装了则跳过第一步）    # 下载、解压 JDK8，下载地址可以从官网获取wget http://download.oracle.com/otn-pub/java/jdk/8u161-b12/2f38c3b165be4555a1fa6e98c45e0808/jdk-8u161-linux-x64.tar.gz?AuthParam=1520068673_6f545cf32470b83658219011266e65b8# 配置 Java 环境变量vi /etc/profile# 在文件尾部添加以下内容export JAVA_HOME=/usr/local/jdk1.8.0_161 (这里是JDK所在目录)export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin# 保存完成后重新加载 /etc/profile 文件source /etc/profile# 测试是否配置正确[root@localhost local]# java -versionjava version "1.8.0_161"Java(TM) SE Runtime Environment (build 1.8.0_161-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.161-b12, mixed mode)        下载 Tomcat    # 下载 Tomcat 9wget http://mirrors.hust.edu.cn/apache/tomcat/tomcat-9/v9.0.5/bin/apache-tomcat-9.0.5.tar.gz# 解压tar -zxvf apache-tomcat-9.0.5.tar.gz# 为接下来的步骤做准备# 重命名为tomcat-homemv apache-tomcat-9.0.5 tomcat-home# 复制第二份，重命名为tomcat-8080cp -R tomcat-home tomcat-8080# 复制第三份，重命名为tomcat-9090cp -R tomcat-home tomcat-9090            分离目录    首先介绍两个 tomcat 中比较重要的概念（通常也是两个系统变量）CATALINA_HOME 和 CATALINA_BASE          CATALINA_HOME：即指向Tomcat安装路径的系统变量（安装目录）      CATALINA_BASE：即指向活跃配置路径的系统变量（工作目录）        通过设置这两个变量，就可以将tomcat的安装目录和工作目录分离，从而实现tomcat多实例的部署。 下面就是 Tomcat 的基本目录结构，以及对应的作用。                            目录          作用                                      bin          存放脚本文件，例如比较常用的启动和关闭脚本 startup.sh、shutdown.sh 等                          conf          存放配置文件，最重要的是 server.xml，它是 tomcat 的主要配置文件                          lib          Tomcat 运行需要的依赖包                          log          存放日志文件                          temp          存放运行时产生的临时文件                          webapps          web 应用的默认目录                          work          主要存放由JSP文件生成的servlet（java文件以及最终编译生成的class文件）                      Tomcat 官方文档 说明了   CATALINA_HOME 路径下需要包含 bin 和 lib 目录，也就是两个支持 tomcat 运行的目录，而 CATALINA_BASE 可以包含所有目录，但是 bin 和 lib 不是必须的，缺省时会使用 CATALINA_HOME 中的 bin 和 lib。因此我们就可以使用一个 CATALINA_HOME 和多个 CATALINA_BASE 部署多个实例，这样的好处是便于管理和升级 Tomcat。上一步我们已经复制了三个 Tomcat，它们的作用分别是：                            目录          作用                                      tomcat-home          作为 CATALINA_HOME，即只需要保留 bin 和 lib 两个文件夹                          tomcat-8080          作为 CATALINA_BASE，需要保留除了 bin 和 lib 之外的其他文件夹，使用 8080 端口                          tomcat-9090          同 tomcat-8080，使用 9090 端口                      基于 CATALINA_HOME 和 CATALINA_BASE 分离目录     # 根据上面表格整理完目录之后，目录结构如下： [root@localhost tomcat-home]# ls bin  lib  LICENSE  NOTICE  RELEASE-NOTES  RUNNING.txt [root@localhost tomcat-8080]# ls conf  LICENSE  logs  NOTICE  RELEASE-NOTES  RUNNING.txt  temp  webapps  work [root@localhost tomcat-9090]# ls conf  LICENSE  logs  NOTICE  RELEASE-NOTES  RUNNING.txt  temp  webapps  work            修改 Tomcat 配置文件    这一步主要是修改 server.xml 中端口的配置，在 server.xml 中配置了四个监听端口，分别是：          Server port(默认8005): 监听关闭 tomcat 的 shutdown 命令      Connector port(默认8080)：监听 http 请求      AJP Connector port(默认8009)：监听 AJP 请求      redirectPort(默认8443)：重定向端口，出现在Connector配置中，如果该Connector仅支持非SSL的普通http请求，那么该端口会把https的请求转发到这个Redirect Port指定的端口。        了解了监听的各个端口的作用之后就可以开始修改 server.xml 了，如果不使用 AJP 请求，那么我们只需要保证多实例中的 Server port 和 Connector port 不同即可。     # tomcat-8080 保持默认配置即可 # 修改 tomcat-9090 的配置，修改后的 /usr/local/tomcat-9090/conf/server.xml 内容如下： ... &lt;Server port="9005" shutdown="SHUTDOWN"&gt; ... &lt;Connector port="9090" protocol="HTTP/1.1"            connectionTimeout="20000"            redirectPort="8443" /&gt; ...            编写脚本    前面的准备工作做完之后就可以启动 tomcat 了，但是现在只有 tomcat-home/bin 目录下有 startup.sh 和 shutdown.sh，而我们要启动的 8080 和 9090 两个实例，因此我们就需要编写一段脚本，修改 CATALINA_BASE 来达到分别操作两个实例的目的。       - 启动脚本 start.sh：     #!/bin/sh CUR_DIR=`dirname $BASH_SOURCE` export CATALINA_BASE=`readlink -f $CUR_DIR` export CATALINA_HOME="/usr/local/tomcat-home"     if [ -f $CATALINA_HOME/bin/startup.sh ]; then         $CATALINA_HOME/bin/startup.sh else         echo "$CATALINA_HOME/bin/startup.sh not exist" fi            停止脚本 stop.sh：      #!/bin/sh  CUR_DIR=`dirname $BASH_SOURCE`  export CATALINA_BASE=`readlink -f $CUR_DIR`  export CATALINA_HOME="/usr/local/tomcat-home"      if [ -f $CATALINA_HOME/bin/shutdown.sh ]; then          $CATALINA_HOME/bin/shutdown.sh  else          echo "$CATALINA_HOME/bin/shutdown.sh not exist"  fi        将这两个脚本文件放在 tomcat-8080 和 tomcat-9090 的根目录下即可      [root@localhost tomcat-8080]# ls  conf     logs    RELEASE-NOTES  start.sh  temp     work  LICENSE  NOTICE  RUNNING.txt    stop.sh   webapps      # 启动 8080 端口的 tomcat  [root@localhost tomcat-8080]# ./start.sh   Using CATALINA_BASE:   /usr/local/tomcat-8080  Using CATALINA_HOME:   /usr/local/tomcat-home  Using CATALINA_TMPDIR: /usr/local/tomcat-8080/temp  Using JRE_HOME:        /usr/local/jdk1.8.0_161  Using CLASSPATH:       /usr/local/tomcat-home/bin/bootstrap.jar:/usr/local/tomcat-home/bin/tomcat-juli.jar  Tomcat started.  # 停止  [root@localhost tomcat-8080]# ./stop.sh   Using CATALINA_BASE:   /usr/local/tomcat-8080  Using CATALINA_HOME:   /usr/local/tomcat-home  Using CATALINA_TMPDIR: /usr/local/tomcat-8080/temp  Using JRE_HOME:        /usr/local/jdk1.8.0_161  Using CLASSPATH:       /usr/local/tomcat-home/bin/bootstrap.jar:/usr/local/tomcat-home/bin/tomcat-juli.jar                测试两个 Tomcat 是否同时正常运行    为了方便测试，在 /usr/local/tomcat-8080/webapps/ROOT 和 /usr/local/tomcat-9090/webapps/ROOT 目录下分别新建一个 index.html 文件，内容分别为 “tomcat-8080” 和 “tomcat-9090” 便于我们区分。完成之后使用 start.sh 启动两个实例，这里我们同样使用 curl 访问来测试。     # 访问 9090 端口，获取到 9090 的数据 [root@localhost tomcat-9090]# curl localhost:9090 &lt;h1&gt; tomcat-9090 &lt;/h1&gt; # 访问 8080 端口，获取到 8080 的数据 [root@localhost tomcat-8080]# curl localhost:8080 &lt;h1&gt; tomcat-8080 &lt;/h1&gt;      Nginx 与 Tomcat 结合Ngnix 和 Tomcat 结合实现负载均衡的需求大概是这样的：用户访问服务器的 8888 端口，Ngnix 接收到请求之后转发至 8080 端口或者 9090 端口由 Tomcat 处理。两个 Tomcat 部署了同一个应用，这样就可以实现负载均衡，可以由两个 Tomcat 同时处理用户请求。这里我们以 localhost 为例，开始配置 Ngnix  这里使用 localhost 作为示例，正式使用时在配置文件中使用域名替换 localhost 即可# 进入 ngnix 配置文件的目录# 默认配置文件是 ngnix.conf/usr/local/nginx/conf# 这里我们新建一个 localhost.conf 单独配置，内容如下：upstream localhost {        server 127.0.0.1:8080;        server 127.0.0.1:9090;}server        {                listen       8888;                server_name localhost;                index index.html index.htm index.jsp index.php;                location / {                        proxy_pass http://localhost;                        proxy_set_header X-Real-IP $remote_addr;                        add_header X-Slave $upstream_addr;                }        }# 接着将在 nginx.conf 中引入 localhost.conf...http {    ...    # 引入 localhost.conf;    include /usr/local/nginx/conf/localhost.conf;    ...}...# 完成配置文件修改之后可以通过 ./nginx -t 命令测试配置文件是否正确cd /usr/local/nginx/sbin/./nginx -t# 出现下面提示表示配置正确，如果有误的话检查配置文件nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is oknginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful# 重载 ngnix 配置文件./nginx -s reload至此，Nginx + Tomcat 的负责均衡服务器已经搭建完成，现在访问 localhost:8888 就可以看到两个 Tomcat 都能处理来自 8888 端口的请求了[root@localhost sbin]# curl localhost:8888&lt;h1&gt; tomcat-8080 &lt;/h1&gt;[root@localhost sbin]# curl localhost:8888&lt;h1&gt; tomcat-9090 &lt;/h1&gt;负载均衡策略上面我们使用的是 Nginx 默认的负载均衡策略，我们也可以根据自己需求配置其他的策略，Nginx 提供的策略主要有以下几种：      轮询（默认）    每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器挂掉，能自动忽略该服务器。     upstream localhost {     server 127.0.0.1:8080;     server 127.0.0.1:9090; }            权重    根据配置的权重去分配给不同的服务器处理，适用于服务器性能有差距的情况，可以个高性能的服务器分配高权重     upstream localhost {     server 127.0.0.1:8080 weight=1;     server 127.0.0.1:9090 weight=3; }            IP 绑定 ip_hash    每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。     upstream localhost {     ip_hash;      server 127.0.0.1:8080;     server 127.0.0.1:9090; }            最少连接    将请求分配给当前连接数最少的服务器     upstream localhost {     least_conn;      server 127.0.0.1:8080;     server 127.0.0.1:9090; }      总结以上，在 CentOS 上使用 Nginx + Tomcat 搭建负载均衡服务器已经完成，搭建过程中主要是理解如何利用 CATALINA_HOME 和 CATALINA_BASE 实现 Tomcat 的多实例部署，在完成 Tomcat 多实例部署的基础上结合 Nginx 实现负载均衡就很简单了。]]></content>
      <categories>
        
          <category> 服务器 </category>
        
      </categories>
      <tags>
        
          <tag> Nginx </tag>
        
          <tag> Tomcat </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
